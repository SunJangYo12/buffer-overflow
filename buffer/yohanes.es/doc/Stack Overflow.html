<!DOCTYPE html>
<html xmlns:fb="http://www.facebook.com/2008/fbml"><head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="Stack%20Overflow_files/css.css" rel="stylesheet" type="text/css">
<link rel="openid2.provider" href="https://www.google.com/accounts/o8/ud?source=profiles">
<link rel="openid2.local_id" href="https://www.google.com/profiles/yohanes">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Stack Overflow</title>
<link rel="icon" href="https://yohan.es/favicon.ico" type="image/x-icon">
<link href="Stack%20Overflow_files/style.css" rel="stylesheet">
<link href="Stack%20Overflow_files/bootstrap.css" rel="stylesheet">
<style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
    </style>
<link href="Stack%20Overflow_files/bootstrap-responsive.css" rel="stylesheet">
<!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
<meta name="google-site-verification" content="nfHXplO1gBCV_4iGIfDjeOZ1vtNvV3JknSYms0ZdiHI">
<script src="Stack%20Overflow_files/sdk_002.js" async="" crossorigin="anonymous"></script><script id="facebook-jssdk" src="Stack%20Overflow_files/sdk.js"></script><script type="text/javascript" async="" src="Stack%20Overflow_files/ga.js"></script><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28573496-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
<script async="" src="Stack%20Overflow_files/lazysizes.html" type="text/javascript"></script>
<style type="text/css">.fb_hidden{position:absolute;top:-10000px;z-index:10001}.fb_reposition{overflow:hidden;position:relative}.fb_invisible{display:none}.fb_reset{background:none;border:0;border-spacing:0;color:#000;cursor:auto;direction:ltr;font-family:"lucida grande", tahoma, verdana, arial, sans-serif;font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:1;margin:0;overflow:visible;padding:0;text-align:left;text-decoration:none;text-indent:0;text-shadow:none;text-transform:none;visibility:visible;white-space:normal;word-spacing:normal}.fb_reset>div{overflow:hidden}@keyframes fb_transform{from{opacity:0;transform:scale(.95)}to{opacity:1;transform:scale(1)}}.fb_animate{animation:fb_transform .3s forwards}
.fb_dialog{background:rgba(82, 82, 82, .7);position:absolute;top:-10000px;z-index:10001}.fb_dialog_advanced{border-radius:8px;padding:10px}.fb_dialog_content{background:#fff;color:#373737}.fb_dialog_close_icon{background:url(https://z-p3-static.xx.fbcdn.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 0 transparent;cursor:pointer;display:block;height:15px;position:absolute;right:18px;top:17px;width:15px}.fb_dialog_mobile .fb_dialog_close_icon{left:5px;right:auto;top:5px}.fb_dialog_padding{background-color:transparent;position:absolute;width:1px;z-index:-1}.fb_dialog_close_icon:hover{background:url(https://z-p3-static.xx.fbcdn.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -15px transparent}.fb_dialog_close_icon:active{background:url(https://z-p3-static.xx.fbcdn.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -30px transparent}.fb_dialog_iframe{line-height:0}.fb_dialog_content .dialog_title{background:#6d84b4;border:1px solid #365899;color:#fff;font-size:14px;font-weight:bold;margin:0}.fb_dialog_content .dialog_title>span{background:url(https://z-p3-static.xx.fbcdn.net/rsrc.php/v3/yd/r/Cou7n-nqK52.gif) no-repeat 5px 50%;float:left;padding:5px 0 7px 26px}body.fb_hidden{height:100%;left:0;margin:0;overflow:visible;position:absolute;top:-10000px;transform:none;width:100%}.fb_dialog.fb_dialog_mobile.loading{background:url(https://z-p3-static.xx.fbcdn.net/rsrc.php/v3/ya/r/3rhSv5V8j3o.gif) white no-repeat 50% 50%;min-height:100%;min-width:100%;overflow:hidden;position:absolute;top:0;z-index:10001}.fb_dialog.fb_dialog_mobile.loading.centered{background:none;height:auto;min-height:initial;min-width:initial;width:auto}.fb_dialog.fb_dialog_mobile.loading.centered #fb_dialog_loader_spinner{width:100%}.fb_dialog.fb_dialog_mobile.loading.centered .fb_dialog_content{background:none}.loading.centered #fb_dialog_loader_close{clear:both;color:#fff;display:block;font-size:18px;padding-top:20px}#fb-root #fb_dialog_ipad_overlay{background:rgba(0, 0, 0, .4);bottom:0;left:0;min-height:100%;position:absolute;right:0;top:0;width:100%;z-index:10000}#fb-root #fb_dialog_ipad_overlay.hidden{display:none}.fb_dialog.fb_dialog_mobile.loading iframe{visibility:hidden}.fb_dialog_mobile .fb_dialog_iframe{position:sticky;top:0}.fb_dialog_content .dialog_header{background:linear-gradient(from(#738aba), to(#2c4987));border-bottom:1px solid;border-color:#043b87;box-shadow:white 0 1px 1px -1px inset;color:#fff;font:bold 14px Helvetica, sans-serif;text-overflow:ellipsis;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0;vertical-align:middle;white-space:nowrap}.fb_dialog_content .dialog_header table{height:43px;width:100%}.fb_dialog_content .dialog_header td.header_left{font-size:12px;padding-left:5px;vertical-align:middle;width:60px}.fb_dialog_content .dialog_header td.header_right{font-size:12px;padding-right:5px;vertical-align:middle;width:60px}.fb_dialog_content .touchable_button{background:linear-gradient(from(#4267B2), to(#2a4887));background-clip:padding-box;border:1px solid #29487d;border-radius:3px;display:inline-block;line-height:18px;margin-top:3px;max-width:85px;padding:4px 12px;position:relative}.fb_dialog_content .dialog_header .touchable_button input{background:none;border:none;color:#fff;font:bold 12px Helvetica, sans-serif;margin:2px -12px;padding:2px 6px 3px 6px;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog_content .dialog_header .header_center{color:#fff;font-size:16px;font-weight:bold;line-height:18px;text-align:center;vertical-align:middle}.fb_dialog_content .dialog_content{background:url(https://z-p3-static.xx.fbcdn.net/rsrc.php/v3/y9/r/jKEcVPZFk-2.gif) no-repeat 50% 50%;border:1px solid #4a4a4a;border-bottom:0;border-top:0;height:150px}.fb_dialog_content .dialog_footer{background:#f5f6f7;border:1px solid #4a4a4a;border-top-color:#ccc;height:40px}#fb_dialog_loader_close{float:left}.fb_dialog.fb_dialog_mobile .fb_dialog_close_button{text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog.fb_dialog_mobile .fb_dialog_close_icon{visibility:hidden}#fb_dialog_loader_spinner{animation:rotateSpinner 1.2s linear infinite;background-color:transparent;background-image:url(https://z-p3-static.xx.fbcdn.net/rsrc.php/v3/yD/r/t-wz8gw1xG1.png);background-position:50% 50%;background-repeat:no-repeat;height:24px;width:24px}@keyframes rotateSpinner{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
.fb_iframe_widget{display:inline-block;position:relative}.fb_iframe_widget span{display:inline-block;position:relative;text-align:justify}.fb_iframe_widget iframe{position:absolute}.fb_iframe_widget_fluid_desktop,.fb_iframe_widget_fluid_desktop span,.fb_iframe_widget_fluid_desktop iframe{max-width:100%}.fb_iframe_widget_fluid_desktop iframe{min-width:220px;position:relative}.fb_iframe_widget_lift{z-index:1}.fb_iframe_widget_fluid{display:inline}.fb_iframe_widget_fluid span{width:100%}</style></head>
<body>
<div id="fb-root" class=" fb_reset"><div style="position: absolute; top: -10000px; width: 0px; height: 0px;"><div></div></div></div>
<script type="text/javascript">(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.3&appId=151853914827909";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<div class="navbar navbar-inverse navbar-fixed-top">
<div class="navbar-inner">
<div class="container">
<a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
<span class="icon-bar"></span>
<span class="icon-bar"></span>
<span class="icon-bar"></span>
</a>
<a class="brand" href="https://yohan.es/">Yohan.es</a>
<div class="nav-collapse collapse">
<ul class="nav">
<li><a href="https://yohan.es/applications/">My Apps</a></li>
<li><a href="https://yohan.es/blackberry/">BlackBerry</a></li>
<li><a href="https://yohan.es/android/">Android</a></li>
<li><a href="https://yohan.es/playbook/">PlayBook</a></li>
<li><a href="https://yohan.es/gadget/">Gadgets</a></li>
</ul>
<form action="https://yohan.es/search/" id="cse-search-box" class="navbar-form pull-right">
<div>
<input type="hidden" name="cx" value="partner-pub-2563024894235569:kg15mqcozdt">
<input type="hidden" name="cof" value="FORID:10">
<input type="hidden" name="ie" value="ISO-8859-1">
<input type="text" name="q" size="31" style="background: rgb(255, 255, 255) url(&quot;https://www.google.com/cse/static/images/1x/googlelogo_lightgrey_46x16dp.png&quot;) no-repeat scroll left center; text-indent: 48px;" placeholder="Custom Search">
<input type="submit" name="sa" value="Search" class="btn">
</div>
<input name="siteurl" type="hidden" value="yohan.es/security/buffer-overflow/basic-stack-overflow/"><input name="ref" type="hidden" value="yohan.es/security/buffer-overflow/"><input name="ss" type="hidden"></form>
</div>
</div>
</div>
</div>

<div class="container">

<div id="content">
<script type="text/javascript" src="Stack%20Overflow_files/brand"></script>

<div id="page" style="padding-top: 0px;">
<h1><a name="index1h1"></a>Stack Overflow</h1>
<p>Bentuk buffer overflow yang paling sederhana adalah stack overflow. 
Di hampir semua OS populer, ini tidak lagi mudah dilakukan karena sudah 
ada banyak metode untuk mengatasinya (ini akan diceritakan di bagian 
lain, tentang teknik mitigasi stack overflow).</p>
<p>Dalam bagian ini saya akan membahas mengenai stack dan hubungannya 
dengan eksekusi program. Saya akan menjelaskan layout stack ketika 
sebuah fungsi dipanggil, termasuk juga jika fungsi itu memiliki variabel
 lokal. Terakhir saya akan menunjukkan bagaimana membajak alur eksekusi 
program dengan menggunakan stack buffer overflow.</p>
<p>Dalam bagian ini saya belum akan membahas shell code. Ini akan dibahas di seri berikutnya.</p>
<p>Berikut ini urutan pembahasan yang akan saya lakukan:</p>
<div class="toc">
<ol>
<li class="L2"><a href="#index1h2">Stack dan eksekusi program</a>
</li>
<li class="L2"><a href="#index2h2">Stack dan parameter</a>
</li>
<li class="L2"><a href="#index3h2">Stack dan variabel lokal</a>
</li>
<li class="L2"><a href="#index4h2">Stack dan variabel lokal array (dan stack overflow)</a>
</li>
<li class="L2"><a href="#index5h2">Exploitasi stack overflow sederhana: mengalihkan ke fungsi lain</a>
</li>
<li class="L2"><a href="#index6h2">Penutup</a>
</li>
</ol>
</div>
<h2><a name="index1h2"></a>Stack dan eksekusi program</h2>
<p>Ketika sebuah program berjalan, ada dua slot memori yang disediakan, 
yang satu adalah heap dan yang lain adalah stack. Heap digunakan untuk 
menyimpan variabel global dan alokasi dinamik, sementara stack digunakan
 untuk menyimpan variabel lokal, menyimpan alamat pada saat pemanggilan 
fungsi dan menyimpan nilai-nilai parameter dan kembalian untuk fungsi 
yang dipanggil.</p>
<p>Struktur data stack memiliki 2 operasi: push dan pop. Push artinya 
menaruh elemen ke stack dan pop artinya mengambil elemen dari stack. 
Stack bisa bergerak/bertumbuh (<em>grows</em>) naik atau turun.</p>
<p>Dalam paragraf ini, asumsikan ukuran 1 elemen stack adalah 1 byte. 
Bergerak naik artinya: setelah menambah elemen di stack, posisinya 
ditambah. Misalnya stack di posisi 1000, lalu kita masukkan 1 elemen, 
maka stack jadi di posisi 1001. Jika bergerak turun, stack 
diinisialisasi dengan sebuah nilai (misalnya: 2000), setiap kita 
memasukkan elemen, posisinya berkurang, jadi dalam kasus ini, setelah 
masuk satu elemen, posisi stack ada di 1999, masuk elemen berikutnya, 
posisinya jadi 1998. Dalam stack yang bergerak turun (<em>grows down</em>)
 Jika posisi stack sampai kurang 0, berarti stack tidak mampu lagi 
menampung apapun (overflow). Perlu dicatat meski dalam paragraf ini saya
 mengasumsikan ukuran satu elemen stack itu 1 byte, biasanya ukuran 
stack adalah kelipatan 4 byte.</p>
<p>Agar lebih mudah, berikutnya saya akan mengasumsikan arsitektur x86 
32 bit. Sebagai informasi, di Intel x86 stacknya bergerak turun. Di 
Intel x86, lokasi stack ditunjuk oleh register sp (16 bit), esp (32 
bit), atau rsp (64 bit). Ukuran elemen stack adalah 16 bit (2byte) di 
sistem 16 bit, 32 bit (4 byte) di sistem 32 bit, dan 64 bit (8 byte) di 
sistem 64 bit. Untuk contoh dalam bagian tulisan ini, saya gunakan 
sistem 32 bit, dengan ESP dimulai dari alamat 1028 desimal. Gambar yang 
akan saya buat adalah seperti ini: Warna merah adalah posisi stack 
pointer. Saya menggunakan <code>?</code> untuk menyatakan bahwa nilai di lokasi memori itu tidak/belum terdefinisi.</p>

<p><img src="Stack%20Overflow_files/ditaa-stack-1.png" alt="ditaa-stack-1.png"></p>
<p>Jadi elemen pertama yang masuk ada di paling kanan, kalau ada elemen berikutnya, masuk di sebelah kiri dst.</p>
<p>Di X86, ketika kita mempush sebuah nilai, pertama nilai stack 
dikurangi dulu, lalu datanya ditaruh, jadi kali pertama sebuah nilai 
dipush (misalnya 10), hasilnya adalah seperti ini:</p>

<p><img src="Stack%20Overflow_files/ditaa-stack-1a.png" alt="ditaa-stack-1a.png"></p>
<p>Ketika operasi pop dilakukan, pertama nilai di posisi esp disalin, lalu esp ditambah.</p>
<h3><a name="index1h3"></a>Stack dan return address</h3>
<p>Setiap kali sebuah kode program memanggil (<code>call</code>) kode 
program lain (biasanya fungsi/prosedur), maka perlu prosessor perlu 
mengingat instruksi selanjutnya setelah call ini di alamat mana (ini 
disebut <em>return address</em> atau alamat kembali), supaya tahu harus 
meneruskan ke alamat mana setelah fungsi tersebut selesai . Posisi 
alamat berikutnya ini disimpan di stack.</p>
<p>Contoh pemanggilan fungsi <code>proc1</code> tanpa parameter dalam assembly adalah seperti ini (angka di kiri adalah alamat letak instruksi tersebut berada):</p>
<pre><code>0x10000 call proc1
0x10004 call proc2
0x10008 ... ; other instructions
</code></pre>
<p>Isi proc 1:</p>
<pre><code>ret    ; fungsi kosong, hanya kembali
</code></pre>
<p>Ketika <code>calll proc1</code> dieksekusi, maka alamat 0x10004 dipush di stack.</p>

<p><img src="Stack%20Overflow_files/ditaa-stack-2.png" alt="ditaa-stack-2.png"></p>
<p>Ketika proc1 selesai, maka instruksi <code>ret</code> (return) dieksekusi. Instruksi ini akan mem-<code>pop</code>
 isi stack, dan melompat ke alamat yang ada di stack (dalam kasus ini 
melompat ke instruksi di 0x10004). Berikutnya ketika proc2 dipanggil, 
alamat setelah <code>call proc2</code> akan dipush distack.</p>
<blockquote><p>Catatan tambahan: untuk optimasi, beberapa compiler (misalnya gcc versi baru) tidak menggunakan instruksi <code>push</code>, tapi menggunakan instruksi <code>mov</code> dengan index <code>esp</code></p></blockquote>
<h2><a name="index2h2"></a>Stack dan parameter</h2>
<p>Jika fungsi memiliki parameter, maka parameter ini bisa diberikan 
kepada fungsi melalui register atau melalui stack. Jika jumlah parameter
 tidak banyak dan merupakan tipe dasar (int, pointer) maka register bisa
 digunakan, jika banyak atau bukan tipe dasar, maka stack akan 
digunakan. Jika menggunakan register, tentunya stack tidak disentuh. 
Pemanggil fungsi akan mengeset beberapa nilai di register, dan fungsi 
akan membaca parameternya dari register. Ketentuan mengenai apa yang 
dilewatkan melalui register dan apa yang dilewatkan melalui stack 
merupakan masalah besar ketika dulu ada banyak compiler, saat ini ada 
beberapa konvensi yang disetujui bersama, detailnya bisa dilihat di <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">http://en.wikipedia.org/wiki/X86_calling_conventions</a></p>
<p>Jika stack yang dipakai, maka pemanggil perlu mem-<code>push</code> parameter ke stack. Misalnya <code>proc1</code> adalah fungsi yang memiliki 1 parameter berupa integer (<code>void proc1(int param)</code>).</p>
<pre><code>0x10000 push $1234
0x10005 call proc1
0x10009 ... ; other instructions
</code></pre>
<blockquote><p>Syntax assembly yang populer untuk x86 ada 2: intel dan at&amp;t. Syntax intel banyak dipakai di lingkungan DOS/Windows.
Saya sekarang memakai syntax at&amp;t (default gcc). Hal paling penting yang perlu diperhatikan adalah urutan operan terbalik
antara at&amp;t dan intel (<code>MOV EAX, EBX</code> menjadi <code>movl %ebx, %eax</code>).</p></blockquote>
<p>Yang terjadi di sini adalah: angka 1234 di-push ke stack, lalu ketika
 proc1 dipanggil (0x10005) maka alamat 0x10009 dipush ke stack juga. 
Posisi stack ketika masuk ke <code>proc1</code> adalah seperti ini:</p>

<p><img src="Stack%20Overflow_files/ditaa-stack-3.png" alt="ditaa-stack-3.png"></p>
<p>Jika ada lebih dari satu parameter <code>void proc1(int param1, int param2)</code>, yang terakhir di-push pertama (konvensi standar C):</p>
<pre><code>0x10000 push $5678 ;parameter ke-1
0x10005 push $1234 ;parameter ke-2
0x10009 call proc1
0x1000C ... ; other instructions
</code></pre>

<p><img src="Stack%20Overflow_files/ditaa-stack-4.png" alt="ditaa-stack-4.png"></p>
<p>Di sisi fungsi yang dipanggil: data yang berada di top of stack (<code>[sp]</code>)
 adalah alamat kembali, dan data berikutnya adalah parameter pertama 
(misalnya ukuran elemen stack adalah 4 byte, maka parameter ada di 
alamat: <code>[sp+4]</code>, ingat stack di x86 bergerak turun). Mengakses parameter dengan cara <code>[sp+4]</code>
 merepotkan karena posisi stack selalu berubah-ubah selama fungsi 
berjalan (misalnya ketika fungsi tersebut memanggil fungsi lain, atau 
melakukan komputasi yang butuh stack).</p>
<p>Biasanya cara yang digunakan adalah menyimpan posisi stack saat ini 
(esp) ke dalam register ebp, dan setelah itu akses bisa dilakukan via 
register ebp.</p>
<pre><code>mov    %esp,%ebp
</code></pre>
<p>Tapi masalahnya isi register ebp sendiri perlu disimpan (kalau tidak,
 nilainya akan kacau setelah kita memanggil sebuah fungsi). Lalu ebp ini
 perlu disimpan di mana? di stack. Jadi biasanya bagian awal suatu 
fungsi adalah seperti ini:</p>
<pre><code>push   %ebp
mov    %esp,%ebp
</code></pre>
<p>dan diakhiri seperti ini:</p>
<pre><code>pop    %ebp
ret
</code></pre>
<p>Karena <code>esp</code> sudah disalin ke <code>ebp</code>, maka untuk mengakses parameter pertama, kita menggunakan <code>[ebp+8]</code>, ingat tadinya <code>[esp+4]</code>, tapi perlu ditambah 4 karena kita menambah <code>ebp</code> ke stack.</p>
<h2><a name="index3h2"></a>Stack dan variabel lokal</h2>
<p>Sekarang kita masuk ke kegunaan stack berikutnya: untuk menampung 
variabel lokal. Untuk menampung variabel lokal, stack tidak dianggap 
sebagai stack (tidak diakses dengan push/pop), tapi dianggap sebagai 
lokasi memori yang kontigu. Compiler akan menghitung berapa besar 
variabel lokal yang dibutuhkan lalu akan mengurangi nilai stack (ini 
efeknya terhadap <code>esp</code> seperti mem-push banyak data). Ini dilakukan dengan instruksi sub, misalnya</p>
<pre><code>sub    $0x10,%esp ; alokasikan 16 byte (10 heksadesimal) untuk variabel lokal
</code></pre>
<blockquote><p>Compiler biasanya mengalokasikan lebih banyak dari seharusnya sesuai dengan alignment CPU, dan juga level optimasi compiler.
Anda bisa membaca mengenai alignment di <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">http://en.wikipedia.org/wiki/Data_structure_alignment</a></p></blockquote>
<p>Misalnya fungsi C seperti ini:</p>
<pre><code>void f()
{
    int d;
    int e;
}
</code></pre>
<p>Total memori yang dibutuhkan: 8 byte. Dalam assembly, fungsi di atas 
adalah seperti ini (dengan setting agar optimasi tidak dilakukan oleh 
compiler):</p>
<pre><code>0:   55                      push   %ebp
1:   89 e5                   mov    %esp,%ebp
3:   83 ec 10                sub    $0x10,%esp
6:   c9                      leave
7:   c3                      ret
</code></pre>
<p>Perhatikan instruksi <code>leave</code> instruksi tersebut sama dengan:</p>
<pre><code>mov %esp, %ebp
pop %ebp
</code></pre>
<blockquote><p>Pada compiler gcc, ada beberapa cara mendapatkan listing assembly dari kode C. Pertama dengan <code>-S</code>, program tidak akan dicompile, dan assembly akan dihasilkan dengan banyak simbol tambahan</p>
<pre><code> gcc -S namafile.c
</code></pre>
<p>Alternatif lain adalah dengan mengkompilasi seperti biasa, lalu kita mendisassemble object filenya (<code>.o</code>) atau executable filenya.</p>
<pre><code>objdump -d namafile.o
</code></pre>
<p>Alternatif lain lagi adalah dengan menggunakan <code>gdb</code> (GNU debugger)</p>
<pre><code>gdb nama_file_exe
(gdb) disas nama_fungsi
</code></pre></blockquote>
<p>Kembali ke topik, sebenarnya hanya diperlukan 8 byte untuk fungsi f, 
tapi compiler menyiapkan 16 byte ini kadang dilakukan untuk optimasi. 
Contoh berikutnya jika kita melakukan operasi pada <code>d</code>.</p>
<pre><code>void f()
{
    int d;
    int e;
    d = 2;
    e = 3;
}
</code></pre>
<p>Dalam assembly:</p>
<pre><code> 0:   55                      push   %ebp
 1:   89 e5                   mov    %esp,%ebp
 3:   83 ec 10                sub    $0x10,%esp
 6:   c7 45 f8 02 00 00 00    movl   $0x2,-0x8(%ebp)
 d:   c7 45 fc 03 00 00 00    movl   $0x3,-0x4(%ebp)
14:   c9                      leave
15:   c3                      ret
</code></pre>
<p>Instruksi di alamat 6 menunjukkan bahwa variabel lokal pertama diakses dengan <code>[ebp-8]</code>, dan variabel lokal kedua dengan <code>[ebp-4]</code>.</p>
<p>Anggap fungsi <code>f</code> dipanggil seperti ini:</p>
<pre><code>0x100000 call f
0x100005 .. ;instruksi lain
</code></pre>
<p>Dan di fungsi <code>f</code> itu sendiri adalah seperti ini:</p>
<pre><code> push   %ebp   
 mov    %esp,%ebp  ; di sini EBP = ESP = 1020
 sub    $0x10,%esp
 movl   $0x2,-0x8(%ebp) ; variabel lokal d
 movl   $0x3,-0x4(%ebp) ; variabel lokal e
 leave
 ret
</code></pre>
<p>Maka isi stack setelah instruksi <code>push %ebp</code> adalah:</p>

<p><img src="Stack%20Overflow_files/ditaa-stack-5.png" alt="ditaa-stack-5.png"></p>
<p>Dan setelah ESP dikurangi 0x10 (16 desimal) <code>sub $0x10,%esp</code></p>

<p><img src="Stack%20Overflow_files/ditaa-stack-6.png" alt="ditaa-stack-6.png"></p>
<h2><a name="index4h2"></a>Stack dan variabel lokal array (dan stack overflow)</h2>
<p>Sekarang saya akan menunjukkan sebuah hal yang menarik: jika kita 
memiliki variabel lokal yang berupa array, bagaimana layout stacknya. 
Saya juga ingin sekaligus menunjukkan contoh buffer overflow dengan 
mengisi variabel melewati deklarasinya.</p>
<pre><code>void a()
{
    int d[2];
    d[0] = 11; //0x0b
    d[1] = 22; //0x16
    d[2] = 33; //0x21
    d[3] = 44; //0x2c

}
</code></pre>
<p>Dalam assembly:</p>
<pre><code> 00000000 &lt;a&gt;:
    0:   55                      push   %ebp
    1:   89 e5                   mov    %esp,%ebp ; di sini EBP = ESP = 1020
    3:   83 ec 10                sub    $0x10,%esp
    6:   c7 45 f8 0b 00 00 00    movl   $0xb,-0x8(%ebp) 
    d:   c7 45 fc 16 00 00 00    movl   $0x16,-0x4(%ebp)
   14:   c7 45 00 21 00 00 00    movl   $0x21,0x0(%ebp)
   1b:   c7 45 04 2c 00 00 00    movl   $0x2c,0x4(%ebp)
   22:   c9                      leave  
   23:   c3                      ret 
</code></pre>
<p>Tanpa opsi optimasi, <code>gcc</code> akan membuat alokasi variabel lokal di stack mirip seperti sebelumnya. Asumsikan fungsi ini dipanggil seperti ini:</p>
<pre><code>0x100000 call a
0x100005 .. ;instruksi lain
</code></pre>

<p><img src="Stack%20Overflow_files/ditaa-stack-7.png" alt="ditaa-stack-7.png"></p>
<p>lokasi memori untuk d[0] dan d[1] terdefinisi di dalam stack, tapi 
d[2] dan d[3] tidak. Akses d[2] bisa menimbulkan error karena mengubah 
ebp yang tersimpan, akses d[3] , bila kita mencoba menimpa d[3] maka 
alamat kembali akan tertimpa. Mengakses varibel array lokal di luar 
range yang terdefinisi menyebabkan <em>stack overflow</em>.</p>
<p>Mengapa C tidak membatasi akses array? Ada dua alasan: pertama 
pengecekan indeks array akan memerlukan komparasi, dan ini tidak 
efisien. Kedua: ada teknik yang membutuhkan akses array lebih dari 
deklarasinya (lihat <em>struct hack</em>: <a href="http://c-faq.com/struct/structhack.html">http://c-faq.com/struct/structhack.html</a>).</p>
<h2><a name="index5h2"></a>Exploitasi stack overflow sederhana: mengalihkan ke fungsi lain</h2>
<p>Lihatlah contoh program kecil ini</p>
<div class="highlight-c"><pre class="hl"><span class="hl ppc">#include &lt;stdio.h&gt;</span>
<span class="hl ppc">#include &lt;stdlib.h&gt;</span>

<span class="hl kwb">void</span> <span class="hl kwd">g</span><span class="hl opt">()</span>
<span class="hl opt">{</span>
    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">"inside g</span><span class="hl esc">\n</span><span class="hl str">"</span><span class="hl opt">);</span>
<span class="hl opt">}</span>

<span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> idx<span class="hl opt">,</span> <span class="hl kwb">int</span> val<span class="hl opt">)</span>
<span class="hl opt">{</span>
    <span class="hl kwb">int</span> b<span class="hl opt">[</span><span class="hl num">1</span><span class="hl opt">];</span>
    <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">"inside f</span><span class="hl esc">\n</span><span class="hl str">"</span><span class="hl opt">);</span>
    b<span class="hl opt">[</span>idx<span class="hl opt">] =</span> val<span class="hl opt">;</span>
<span class="hl opt">}</span>

<span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">()</span>
<span class="hl opt">{</span>
    <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre></div>
<p>Jika fungsi <code>f</code> dipanggil oleh fungsi <code>main</code>, maka fungsi <code>f</code> akan dieksekusi, lalu program akan berhenti. Keluaran program adalah:</p>
<pre><code> inside f
</code></pre>
<p>Kita lihat versi assembly fungsi f (output dari <code>gcc -S</code>):</p>
<pre><code>  .LC1:
        .string      "inside f"
        .text
  .globl f
        .type      f, @function
  f:
        pushl     %ebp
        movl      %esp, %ebp
        subl      $40, %esp
        movl      $.LC1, (%esp)
        call      puts
        movl      8(%ebp), %eax  ; masukkan param pertama (idx) ke eax
        movl      12(%ebp), %edx ; masukkam param kedua (val) ke edx
        movl      %edx, -12(%ebp,%eax,4) ; b mulai dari ebp-12
        leave
        ret
</code></pre>
<p>Atau bagi yang lebih familiar dengan syntax intel.</p>
<pre><code> .LC1:
    .string "inside f"
    .text
 .globl f
    .type   f, @function
 f:
    push    ebp
    mov ebp, esp
    sub esp, 40
    mov DWORD PTR [esp], OFFSET FLAT:.LC1
    call    puts
    mov eax, DWORD PTR [ebp+8]
    mov edx, DWORD PTR [ebp+12]
    mov DWORD PTR [ebp-12+eax*4], edx
    leave
    ret
</code></pre>
<p>Secara singkat: variabel array <code>b</code> dimulai dari <code>ebp-12</code>. Begini keadaan stack setelah <code>subl $40, %esp</code>.</p>

<p><img src="Stack%20Overflow_files/ditaa-stack-8.png" alt="ditaa-stack-8.png"></p>
<p>Setelah mengetahui layout stacknya. Kita bisa menambah baris yang menarik <code>f(4, (int)g);</code>:</p>
<div class="highlight-c"><pre class="hl"><span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">()</span>
<span class="hl opt">{</span>
    <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span> <span class="hl num">1</span><span class="hl opt">);</span>
    <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl num">4</span><span class="hl opt">, (</span><span class="hl kwb">int</span><span class="hl opt">)</span>g<span class="hl opt">);</span>
    <span class="hl kwa">return</span> <span class="hl num">0</span><span class="hl opt">;</span>
<span class="hl opt">}</span>
</pre></div>
<p>Sekarang keluaran program menjadi:</p>
<pre><code>inside f
inside f
inside g
Segmentation fault
</code></pre>
<p>Kenapa bisa begitu? sederhana sekali penjelasannya, ketika baris ini dipanggil:</p>
<pre><code>f(4, (int)g);
</code></pre>
<p>Yang terjadi di fungsi <code>f</code> adalah:</p>
<pre><code>b[idx] = val;    
</code></pre>
<p>Perhatikan bahwa ketika pemanggilan dilakukan: nilai <code>idx</code> adalah 4 dan <code>val</code> adalah alamat fungsi g. Seperti terlihat dalam gambar kondisi stack, d[4] adalah alamat kembali program</p>
<blockquote><p>Catatan: di GCC versi relatif baru, proteksi stack 
diaktifkan secara default (yang menyebabkan stack overflow sulit 
dieksploitasi). Penjelasan mengenai hal ini akan diberikan di bagian 
lain. Jika contoh tidak berjalan, gunakan command line berikut ini <code>gcc -fno-stack-protector -o bug bug.c</code>.</p></blockquote>
<h2><a name="index6h2"></a>Penutup</h2>
<p>Di sini Anda sudah bisa melihat bahwa alur eksekusi program bisa 
dialihkan ke fungsi lain. Sebenarnya pengetahuan ini sudah cukup untuk 
serangan buffer overflow yang disebut dengan "return-to-libc" (ini akan 
dibahas lebih dalam di bagian lain), tapi biasanya kita ingin 
mengeksekusi program kita sendiri ketika terjadi overflow.</p>
<p>Di bagian mengenai shellcode, akan saya tunjukkan bagaimana caranya 
agar kita bisa menginjeksi kode baru yang akan dieksekusi (kode yang 
tidak ada di program), kode baru ini bisa melakukan apa saja yang kita 
inginkan.</p>

<div id="backlinks">
Links:
<a href="https://yohan.es/security/buffer-overflow/">buffer-overflow</a>
</div>
<p class="footer">
Last update: <span class="date">late Wednesday evening, March 27th, 2019</span>
</p>
<p>
Copyright © 2009-2018 Yohanes Nugroho
</p>
</div>
</div>
</div>
<script src="Stack%20Overflow_files/jquery-1.js" type="text/javascript"></script>
<script src="Stack%20Overflow_files/bootstrap.js" type="text/javascript"></script>


</body></html>